unit Math_u;

interface

uses
  Windows, Classes, SysUtils, comctrls, Forms, Types, Vassbotn.Vcl.Complex, Info_u, LicenceComponent_u, ListEditor,
  DesignIntf, Vcl.Graphics;

type
  TVarTyp = (VarNone, Scalar, Vector, Matrix);
  TNS = array[0..99] of String;
  TComplex1D = array of TComplex;
  TComplex2D = array of array of TComplex;
  TXAxisTyp = (Axis_Linear, Axis_Log10, Axis_Ln, Axis_Probability);
  PDouble1D = ^TDouble1D;
  TDouble1D = array of Double;
  PSingle1D = ^TSingle1D;
  TSingle1D = array of Single;
  PSingle2D = ^TSingle2D;
  TSingle2D = array of TSingle1D;
  TPointF1D = array of TPointF;
  TExtended1D = array of Extended;
  TCharSet = set of AnsiChar;
  TAnsiChars = array of AnsiChar;
  TAnsiStrings = array of AnsiString;
  TInteger1D = array of Integer;
  TDouble2D = array of array of Double;
  TExtended2D = array of array of Extended;
  ESyntaxError = class(Exception)
  end;
  TMathObject = class
  public
    constructor Create(const AVarChar: TAnsiStrings);
    destructor Destroy; override;
    function StrToValue(const ASt: String; const Ix: TInteger1D; const V: TExtended1D; ATreeNode: TTreeNode): TComplex;
    function GetValue(const Ix: TInteger1D; const V: TExtended1D): TComplex;
    function IsVarItemUsed(VarItem: TObject): Boolean;
    procedure Assign(Source: TMathObject);
    procedure ClearFunc;
    procedure SaveToStream(Stream: TStream);
    procedure SaveToMemory;
    procedure PaintTree(Canvas: TCanvas; X, Y: Integer);
    procedure Paint(Canvas: TCanvas; BeforeStr: String; X, Y: Integer; LineBreak: Boolean = False);
    property VarChar: TAnsiStrings read FVarChar write SetVarChar;
    property Equation: String read St;
    property VarItems: TContainer read FVarItems write SetVarItems;
    property IsMx: Boolean read FIsMx write FIsMx;
    property Typ: TVarTyp read FTyp;
    property Freq: Double read FFreq write FFreq;
    property ResultVc: TComplex1D read FResultVc;
    property ResultMx: TComplex2D read FResultMx;
    property Width: Integer read FWidth;
    property Height: Integer read FHeight;
    property OnRefresh: TNotifyEvent read FRefresh write FRefresh;
  end;
  TEquation = class(TInfoComponent)
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure ReadVarValues(Stream: TStream);
    procedure WriteVarValues(Stream: TStream);
    procedure DefineProperties(Filer: TFiler); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure Loaded; override;
    property VarValues: TExtended1D read FVarValues;
    property VarValue[I: Integer]: Extended read GetVarValue write SetVarValue;
    function Check(Value: TStrings; var Err: String): Boolean;
    function GetValue(const V: TExtended1D): TComplex;
    procedure PaintTree(Canvas: TCanvas; X, Y: Integer);
    procedure Paint(Canvas: TCanvas; BeforeStr: String; X, Y: Integer; LineBreak: Boolean = False);
    property MathObject: TMathObject read FMathObject;
    property IsError: Boolean read FIsError;
    property OnRepaint: TNotifyEvent read FRepaint write FRepaint;
  published
    property LicenceComponent: TLicenceComponent read FLicenceComponent write SetLicenceComponent;
    property Variables: String read FVariables write SetVariables;
    property Lines: TStrings read FLines write SetLines;
    property TreeView: TTreeView read FTreeView write SetTreeView;
    property OnChange: TNotifyEvent read FChange write FChange;
  end;

const
  MathChars: TCharSet = ['(',')','^','/','*','-','+','<','=','>','[',']',';'];

function IsReserved(MathObject: TMathObject; S: String): Boolean;
function IsFalseChar(Ch: array of Char; S: String): Boolean;
function StrTrim(S: String): String;
function Complex(const Re, Im: Double): TComplex;
function ComplexHypot(const A: TComplex): Double;
function ComplexAdd(const A, B: TComplex): TComplex;
function ComplexSub(const A, B: TComplex): TComplex;
function ComplexPower(const A: TComplex; P: Byte): TComplex;
function ComplexMult(const A, B: TComplex): TComplex;
function ComplexDiv(const A, B: TComplex): TComplex;
function ComplexRot(const A: TComplex; const Beta: Double): TComplex;
function ComplexMultR(const A: TComplex; R: Double): TComplex;
procedure ClearComplexMatrix(var A: TComplex2D);
procedure CopyComplexMatrix(var A: TComplex2D; const B: TComplex2D);
procedure TransposeComplexMatrix(var A: TComplex2D; const B: TComplex2D);
procedure ClearComplexVector(var A: TComplex1D);
procedure CopyComplexVector(var A: TComplex1D; const B: TComplex1D);
procedure MultComplexMatrix(var C: TComplex2D; const A, B: TComplex2D);
procedure MultComplexMxVc(var C: TComplex1D; const A: TComplex2D; const B: TComplex1D);
function AFiR(X0, Y0, X, Y: Double): Double;
function FiR(X0, Y0, X, Y: Double): Double;
function CreateMatrix(R, C: Integer): TExtended2D;
procedure ClearMatrix(var A: TExtended2D);
procedure ClearComplexMx(var A: TComplex2D);
procedure CopyMatrix(var A: TExtended2D; const B: TExtended2D);
procedure CopyComplexMx(var A: TComplex2D; const B: TComplex2D);
procedure ClearVector(var A: TDouble1D);
function CreateVector(R: Integer): TDouble1D;
procedure NVector(var A: TDouble1D; const N: Single);
procedure CopyVector(var A: TDouble1D; const B: TDouble1D);
procedure CopyComplexVc(var A: TComplex1D; const B: TComplex1D);
procedure AddVector(var A: TDouble1D; const B: TDouble1D);
procedure MinusVector(var A: TDouble1D; const B: TDouble1D);
procedure MatrixT(var C: TExtended2D; const A: TExtended2D);
procedure ComplexMxT(var C: TComplex2D; const A: TComplex2D);
procedure NMatrix(var M: TExtended2D; const N: Single);
procedure MultMatrix(var C: TExtended2D; const A, B: TExtended2D);
procedure AddMatrix(var C: TExtended2D; const A: TExtended2D);
procedure MultMxVc(var C: TDouble1D; const A: TExtended2D; const B: TDouble1D);
procedure GEM(var X: TDouble1D; const A: TExtended2D; const Y: TDouble1D);
procedure LUR(var X: TDouble1D; const A: TExtended2D; const Y: TDouble1D);
procedure InvMatrix(var A: TExtended2D; const B: TExtended2D);
procedure ComplexGEM(var X: TComplex1D; const A: TComplex2D; const Y: TComplex1D);
procedure ComplexLUR(var X: TComplex1D; const A: TComplex2D; const Y: TComplex1D);
procedure InvComplexMx(var A: TComplex2D; const B: TComplex2D);
procedure MultComplexMx(var C: TComplex2D; const A, B: TComplex2D);
procedure ComplexEigenMx(var L: TComplex1D; var AE, Y: TComplex2D; const A: TComplex2D);
procedure ComplexRotKM(var O: TComplex1D; var Y: TComplex2D; const K, M: TComplex2D);
function ExplodeCh(const Ch: Char; S: String; var NS: TNS): Integer;
function ExplodeChSet(const Ch: TSysCharset; S: String; var NS: TNS): Integer;
function StrToDouble(S: String): Double;

